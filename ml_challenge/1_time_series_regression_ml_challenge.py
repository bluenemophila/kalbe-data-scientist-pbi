# -*- coding: utf-8 -*-
"""1. Time Series Regression ML Challenge

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/181apO5qQogtSDkLzh2Aa59-0LL0ynSZY

# Data Understanding

## Import Dependencies
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import pmdarima as pm
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, mean_squared_error
# %matplotlib inline

"""## Load Data"""

from google.colab import drive
drive.mount('/content/drive')

# laoding data
customer_table = pd.read_csv('/content/drive/MyDrive/Case Study Data Scientist/Customer.csv', sep=';')
product_table = pd.read_csv('/content/drive/MyDrive/Case Study Data Scientist/Product.csv', sep=';')
store_table = pd.read_csv('/content/drive/MyDrive/Case Study Data Scientist/Store.csv', sep=';')
transaction_table = pd.read_csv('/content/drive/MyDrive/Case Study Data Scientist/Transaction.csv', sep=';')

"""## Deskripsi Tabel"""

customer_table.info()

product_table.info()

store_table.info()

transaction_table.info()

"""# Data Preparation"""

# ubah tanggal transaksi menjadi format datetime
transaction_table['Date'] = pd.to_datetime(transaction_table['Date'], format='%d/%m/%Y')

"""## Menangani missing value"""

customer_table.isnull().sum()

product_table.isnull().sum()

store_table.isnull().sum()

transaction_table.isnull().sum()

"""Karena pada tabel customer, terdapat customer dengan marital status kosong, kita akan mengisinya dengan marital status yang paling sering muncul."""

customer_table['Marital Status'].fillna(customer_table['Marital Status'].mode()[0], inplace=True)

customer_table.isnull().sum()

"""## Menggabungkan tabel"""

merged_data = pd.merge(transaction_table, product_table, on='ProductID', how='left')
merged_data = pd.merge(merged_data, store_table, on='StoreID', how='left')
merged_data = pd.merge(merged_data, customer_table, on='CustomerID', how='left')
merged_data.head()

merged_data.info()

"""## Membuat data baru untuk regresi"""

reg_data = transaction_table.groupby('Date')['Qty'].sum().reset_index()
reg_data['Date'] = pd.to_datetime(reg_data['Date'], format='%d/%m/%Y')
reg_data.sort_values(by='Date', inplace=True)
reg_data.set_index('Date', inplace=True)

len(reg_data)

"""## Visualisasi data

Plor jumlah penjualan harian sepanjang tahun
"""

reg_data.plot(figsize=(12,8), title='Daily Sales', xlabel='Date', ylabel='Total Qty', legend=False)

"""# Time Series Modeling

Sebelum melakukan pemodelan, kita akan melakukan dekomposisi untuk mengetahui apakah data memiliki komponen trend maupun musiman.
"""

decompose = seasonal_decompose(reg_data)

fig,ax = plt.subplots(3,1,figsize=(15,12))
decompose.trend.plot(ax=ax[0])
ax[0].set_title('Trend')
decompose.seasonal.plot(ax=ax[1])
ax[1].set_title('Seasonal')
decompose.resid.plot(ax=ax[2])
ax[2].set_title('Residual')

plt.tight_layout()
plt.show()

"""Telihat dari plot data tersebut, terdapat pola musiman yaitu perulangan pola data pada bulan-bulan tertentu. Sementara itu, tidak terlalu terlihat pola trend atau kecenderungan data untuk naik atau turun seiring periode waktu.

## Cek stasioneritas data
"""

acf_original = plot_acf(reg_data)
pacf_original = plot_pacf(reg_data)

from statsmodels.tsa.stattools import adfuller
adf_test = adfuller(reg_data)
print(f'p-value: {adf_test[1]}')

"""Berdasarkan uji adfuller diketahui p-value = 0.00 < 0.05 maka kita bisa menentukan bahwa series tersebut sudah stasioner.

## Data splitting

Dilakukan pembagian data menjadi 80% data training dan 20% data testing
"""

df_train = reg_data[:int(0.8*(len(reg_data)))]
df_test = reg_data[int(0.8*(len(reg_data))):]

"""## Pemodelan ARIMA"""

auto_arima_model = pm.auto_arima(
    df_train['Qty'],
    seasonal=False,
    stepwise=False,
    suppress_warnings=True,
    trace = True
)
auto_arima_model.summary()

"""Dari model auto arima dihasilkan model dengan parameter terbaik yaitu ARIMA(1,0,1). Jika dilihat dari plot data dan analisis sebelumnya, data memiliki pola musiman sehingga kita dapat memodelkannya dengan SARIMAX.

## Parameter Tuning ARIMA
"""

from itertools import product
p = [40,50,60]
d = [2]
q = [1]
pdq = list(product(p, d, q))

aic_list = []

for param in pdq:
    model = ARIMA(df_train, order=param)
    model_fit = model.fit()
    aic_list.append({'par': param, 'aic': model_fit.aic})

best_aic = min(aic_list, key=lambda x: x['aic'])
print(best_aic)

"""## Pemodelan SARIMAX

### Model Auto
"""

p, d, q = auto_arima_model.order
model = SARIMAX(df_train['Qty'].values, order=(p,d,q))
model_fit = model.fit(disp=False)

from sklearn.metrics import mean_squared_error
predictions = model_fit.predict(start=len(df_train), end=len(df_train)+len(df_test)-1)
rmse = mean_squared_error(df_test, predictions, squared=False)
rmse

"""### Tuned model"""

p, d, q = (40,1,1)
model_tuned = SARIMAX(df_train['Qty'].values, order=(p,d,q))
model_tuned_fit = model.fit(disp=False)

predictions = model_tuned_fit.predict(start=len(df_train), end=len(df_train)+len(df_test)-1)
rmse = mean_squared_error(df_test, predictions, squared=False)
rmse

"""Jika dibandingkan, model terbaik merupakan model auto ML dengan RMSE yang lebih rendah.

## Peramalan penjualan untuk 90 hari kedepan

### Model auto
"""

period = 90
forecast = model_fit.forecast(steps=period)
forecast_tuned = model_tuned_fit.forecast(steps=period)
index = pd.date_range(start='01-01-2023', periods=period)
df_forecast = pd.DataFrame(forecast, index=index, columns=['Qty'])
df_tuned_forecast = pd.DataFrame(forecast_tuned, index=index, columns=['Qty'])

plt.figure(figsize=(12,8))
plt.title('Forecasting Sales')
plt.plot(df_train, label='Train')
plt.plot(df_test, label='Test')
plt.plot(df_forecast, label='Predicted')
plt.plot(df_tuned_forecast, label='Predicted Tuned Model')
plt.legend(loc='best')
plt.show()

df_forecast.astype(int)

df_forecast.describe()

warnings.filterwarnings('ignore')

product_reg_df = merged_data[['Qty', 'Date', 'Product Name']]
new = product_reg_df.groupby("Product Name")

forecast_product_df = pd.DataFrame({'Date': pd.date_range(start='2023-01-01', periods=90)})

for product_name, group_data in new:
    target_var = group_data['Qty']
    model = SARIMAX(target_var.values, order=(p,d,q))
    model_fit = model.fit(disp=False)
    forecast = model_fit.forecast(90)
    forecast_product_df[product_name] = forecast.astype(int)

forecast_product_df.set_index('Date', inplace=True)
forecast_product_df

plt.figure(figsize=(12,8))
for i in forecast_product_df.columns:
    plt.plot(forecast_product_df[i], label=i)
plt.legend(loc=6, bbox_to_anchor=(1,.82))
plt.title('Forecasting Product')
plt.xlabel('Date')
plt.ylabel('Total Qty')
plt.show()